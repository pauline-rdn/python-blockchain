I) INTRO - what do i need to know about Blockchain ?

The Blockchain is a distributed and decentralized ledger that stores data such as transactions, & that is shared across all the nodes of its network.
t is a collection of blocks, and each block acts as a storage unit. 
It is giving a unique value, which is a random string of characters called the Hash (generated by a cryptographic hash function that generates unique output for every unique input - including the data the blocks needs to store).
The last_hash of a block is the key to link a chain of blocks. 

Blockchain is a kind of shared virtual diary, which records all interactions of all diary participants. 
Anyone can write in the journal, and everyone has the same version of it. 
None of the participants has more authority than the others on keeping the diary, and it is not only hosted in one place, because everyone has a copy. 
This is called a decentralized system. In order to guarantee the security of the blockchain, an information verification step has been put in place: 
it is this particular step that will allow mining. Mining refers to the process of validating transactions made on a blockchain 
(or, to take the example of the newspaper, the sentences that are written there).
The validation of these operations is a key step for blockchains, and the process is referred to as the "consensus protocol": 
it is what ensures that all ledgers have the same version. There are different consensus protocols: 
the two most used are proof of work (which concerns bitcoin), and proof of stake.

Cryptocurrency is a digital medium of exchange.
The technology englobes three main aspects : Blockchain, wallets, mining.
It is a cryptographic public database of transactions anyone can access, giving individuals the opportunity to generate unique digital signatures when they record a transaction in the Blockchain.
The signature is based on the pair of cryptographic keys : one is public, the other is private.
Wallets are objects that store the key pair. It has a unique address. 
The private key helps wallet to generate the signature that makes transactions official.

Sha-256 is the hashing algorithm.
It generates a unique output for every unique input. 
Sha-256 produces a unique 256 character hash in binary, and a 64 character hash in hexadecimal.

Encoding is the process of converting data into an alternate representation.

II) CONCEPT AROUND PROOF OF WORK

* Proof of work is a mechanism that requires miners to solve a computational puzzle in order to create valid blocks. 
  Solving the puzzle requires a brute-force algorithm that demands CPU power (the analogy of mining the block).

* The leading 0's requirement is the standard proof of work implementation for finding valid blocks. 
  By adjusting a nonce value in the block, the miner has an infinite number of tries at generating new hashes. 
  Once the miner finds a hash with a matching number of leading 0's as the block difficulty, the fields for valid new block have been found.

* Dynamic difficulty is a mechanism that increases or decreases the difficulty of the next block based on how long it's taking to mine the new block. 
  If the time is exceeding an established mining rate for the system, the difficulty decreases. 
  Likewise, if the time is still before the mine rate, the difficulty increases. 
  This allows the blockchain to control the rate at which blocks are added.
  A high cryptocurrency difficulty means it takes additional computing power to verify transactions entered on a blockchain—a process called mining.

* By converting the hashes from their default hexadecimal form to a binary form, 

With proof of work done, the core of the blockchain data structure itself has been completed. 
But the true power of a blockchain system kicks in once there are multiple contributors to the blockchain's growth. 
The blockchain becomes secure once there are multiple validators to check the healthiness of new block data.

In cryptography, a nonce is an arbitrary number intended to be used only once. 
This is often a random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks1.
A replay attack is a form of network attack in which a transmission is maliciously repeated by an attacker who intercepted the transmission.

STEPS :
- Difficulty & nonce value
- Dynamic difficulty & mine rate
- Proof of work system (average work script)
- Hex to Binary conversion

III) BLOCKCHAIN COLLABORATION & CHAIN VALIDATION

Chain validation is the process of inspecting the blockchain, ensuring that the data of an external blockchain is formatted correctly.
  For the blockchain to be valid, there are multiple rules to enforce : 
  - every block must be valid, with a proper hash based on the block fields
  - correctly adjusted difficulty
  - acceptable number of leading 0's in the hash for the proof of work requirement
  The blockchain itself must start with the genesis block, and every block's last hash must reference the hash of the block that came before it.

* Chain replacement is the process of substituting the current blockchain data for the data of an incoming blockchain. 
  If the incoming blockchain is longer, and valid, then it should replace the current blockchain. 
  This will allow a valid blockchain, with new blocks, to spread across the eventual blockchain network, becoming the true blockchain that all nodes in the blockchain network agree upon.

Needings : correct block fields (timestamp, data, last_hash, hash), last_hash reference, valid hash, valid proof of work.
Blockchain network = when multiple blockchain are interacting with each other.

When we set up the network, every node is gonna have its own instance of a blockchain.

STEPS :
- Block validation
- Chain validation
- Chain replacement

IV) BLOCKCHAIN network

Create a private application & api that will allow an individual to interact with his own blockchain instance.
The api (a medium that allows an external to call code in an existing system) will allow the application owner to conduct actions involving their blockchain.
Option == pub/sub messaging layer that multiple blockchain owner can use to communicate and share the blockchain data.

needings = a web server designed to send ressources to client request (HTTP), a GET http request associated with reading data, 
           a POST http request associated with sending data, a method that reads the blockchain data, a method that mine a new block.


V) CRYPTOCURRENCY - wallets, keys & transactions)

* A wallet keeps track of an individual's amount of currency. Each wallet has an address, and a pair of keys (a private and a public key).
  A wallet has :
    - Balance (how much currency an individual has collected in the blockchain’s history)
    - A private key (generate signatures)
    - A public key (verify signatures)
    - A public address 

* The private key of a wallet must be kept secret. It's used to generate signatures.

* The public key can be publicly shared with other entities.

* Signatures are unique data objects created using the private key. 
  With the signature, public key, and the original data object, other entities can verify if the signature was generated by the true owner of the public key.

* ECDSA stands for elliptic cryptography digital signature algorithm, and it's the underlying implementation of a cryptographic python module. 
  The mathematics behind the system use elliptic curves to create keypairs and signatures.

* A transaction consists of an input and output field. The input contains metadata - including the address, public key, and the balance amount of the sender. 
  The input also includes a signature that's generated by the sender, using the transaction output as the underlying data. 
  The output contains a series of entries where recipient addresses will receive certain amounts as a result of the transaction. 
  The transaction can have any number of recipients. At least one of the recipients is the sender address itself, because this details how much currency the sender should have after the transaction is completed.
  Transaction needings:
	- input (timestamp, balance, sender’s public key, sender’s address)
	- output objects (amount field = how much currency the sender wants to send to the address + address)
	- second output specifying how much output the sender should have after the transaction has processed.

* Validating transactions == checking that the total currency sent to the recipients is correct, and that the signature is correct - according to the presented public key and transaction output.

STEPS :
- Build a wallet object for transactions
- Implement signatures & verification
- Create 'transaction objects' that capture the exchange of currency


VI) TRANSACTIONS ON THE NETWORK

A Transaction pool is a unique set of transactions.
It can update existing stored transactions, can rewrite multiple transactions.
Every node in the network is gonna have its own instance of the transaction pool.
The key makes sure all the transaction pools stay synchronized.
When one node creates a new transaction or update an existing one, the transaction needs to be broadcasted to the entire network.

* More precisely, it is an object that collects transactions that have been broadcasted across the network. 
  It stores transactions according to their id. The idea is that this transaction pool will collect the transactions that miners will use as the basis of data for new blocks.

* Serializing the wallet's public key == the public key's default format is in an encoding format called PEM, that's defined within the cryptography module. 
  By encoding and decoding the public key using this format, a public key can be shared across the network, and restored back when it comes to validating signatures.

VII) CONNECT BLOCKCHAIN & CRYPTOCURRENCY

* By mining transactions into the blockchain, they become official in the cryptocurrency. 
  This means that they can be used to affect wallet balances.

* When a new block of transactions is added to the blockchain, 
  those transactions should be removed from the transaction pool to prevent duplicate transactions from appearing in newly attempted blocks.

* To calculate a balance, you sum the output values sent to a given address since that wallet's most recent transaction. 
  Every time a wallet conducts a new transaction, they create a new "starting point" for the algorithm to calculate a balance.

* The mining reward, a transaction with a standard amount of cryptocurrency, incentivizes miners to continue investing cpu power to mine new blocks. 
  That way, the cryptocurrency's backing blockchain will grow at a steady pace, and continue to make transactions official.

VIII) FRONTEND & REACT

React is a JavaScript framework for web applications. 
React optimizes how JavaScript is used on the browser to make the web app dynamic and efficient.

* React builds a virtual DOM - an internal representation of the browser document within the React engine, 
  in order to optimize its calls to the core document to update the web application.

* The useState hook allows you to create state data local to a component.

* The useEffect hook allows you to fire off a side effect during when a component renders.

* State represents the data local to a component. It can be used to store information throughout the lifetime of the web application.

* The React engine under the hood applies the concept of inversion of control: when you create a React component function, 
  you don't call the function in your application code. 
  Instead, control over this is handed to the React engine. By giving the React engine control over calling your component, 
  and rendering it, they can optimize state updates and document changes to ensure your web application is highly performant. 
  This is also how React augments components to contain state and side effects. 
  When a component where the useState or useEffect hook is applied, internally it will track state for that component or run the useEffect's inner callback.

* The CORS (Cross Origin Resource Sharing) Policy is a security-check that the browser implements to ensure what websites are making authorized requests to backend servers. 
  The browser confirms the recognition by the backend (frontend url as an origin).

* The history object allows the React app to programmatically navigate the user to a new path. 
  The push() method sends the user to a different path based on completing certain actions.
